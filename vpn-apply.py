#!/usr/bin/env python3
"""
VPN Policy Router Configuration Apply Script
This script applies the VPN router configuration from JSON definitions.
"""
import os
import sys
import re
import json
import time
import hashlib
import shutil
import subprocess
import argparse
import logging
import ipaddress
import socket
from pathlib import Path
from datetime import datetime, timezone

# --- Configuration ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger('vpn-router')

CONFIG_DIR = Path("/etc/vpn-router")
NETWORKD_DIR = Path("/etc/systemd/network")
SYSTEMD_DIR = Path("/etc/systemd/system")
VPN_DEFINITIONS_PATH = CONFIG_DIR / "vpn-definitions.json"
VPN_CLIENTS_PATH = CONFIG_DIR / "vpn-clients.json"
GENERATOR_NAME = "vpn-apply.py"
GENERATOR_VERSION = "4.0"

class VPNRouter:
    """Manages the entire lifecycle of VPN configurations."""

    def __init__(self, dry_run=False, auto_mode=False):
        self.dry_run = dry_run
        self.auto_mode = auto_mode
        self.changed_files = set()
        self.vpn_definitions = self._load_json(VPN_DEFINITIONS_PATH)
        self.vpn_clients = self._load_json(VPN_CLIENTS_PATH)
        self._validate_config()

    def _load_json(self, path):
        if path.exists():
            try:
                with open(path, 'r') as f:
                    return json.load(f)
            except json.JSONDecodeError as e:
                logger.error(f"Invalid JSON in {path}: {e}")
                sys.exit(1)
        
        logger.warning(f"Config file not found: {path}. Creating a default.")
        if path == VPN_DEFINITIONS_PATH:
            template = {
                "system_config": {
                    "firewalld": {"zone_lan": "trusted", "zone_vpn": "trusted"},
                    "nftables": {"table": "nat", "chain": "POSTROUTING"},
                    "nat": {"lan_subnets": ["192.168.0.0/16"]}
                },
                "vpn_connections": []
            }
        else:
            template = {"assignments": []}
        
        if not self.dry_run:
            self._write_file(path, json.dumps(template, indent=2))
        return template

    def _validate_config(self):
        logger.debug("Validating configuration...")
        if "system_config" not in self.vpn_definitions:
            raise ValueError("Missing 'system_config' in vpn-definitions.json")
        logger.debug("Configuration validation successful.")

    def _run_cmd(self, cmd, check=True):
        logger.debug(f"Running command: {' '.join(cmd)}")
        if self.dry_run:
            logger.info(f"DRY RUN: Would run: {' '.join(cmd)}")
            return subprocess.CompletedProcess(cmd, 0, stdout="", stderr="")
        try:
            return subprocess.run(cmd, check=check, capture_output=True, text=True)
        except FileNotFoundError:
            logger.error(f"Command not found: {cmd[0]}. Is it installed?")
            return None
        except subprocess.CalledProcessError as e:
            logger.error(f"Command failed: {' '.join(cmd)}\n{e.stderr}")
            return None

    def _write_file(self, path, content, mode=0o644):
        path = Path(path)
        content_hash = hashlib.sha256(content.encode()).hexdigest()
        header = f"# Generated by {GENERATOR_NAME} v{GENERATOR_VERSION}\n# HASH: {content_hash}\n"
        full_content = header + content
        if path.exists():
            try:
                if path.read_text() == full_content: return
            except IOError: pass
        logger.info(f"Writing configuration to {path}")
        self.changed_files.add(str(path))
        if not self.dry_run:
            path.parent.mkdir(parents=True, exist_ok=True)
            path.write_text(full_content)
            path.chmod(mode)

    def _get_network_addresses(self, cidr):
        try:
            net = ipaddress.ip_network(cidr)
            if net.prefixlen != 30: raise ValueError("veth_network must be a /30 subnet.")
            hosts = list(net.hosts())
            return str(hosts[0]), str(hosts[1])
        except ValueError as e:
            logger.error(f"Invalid CIDR '{cidr}': {e}")
            return None, None

    def _get_vpn_resource_files(self, vpn_name):
        host_veth = f"v-{vpn_name}-v"
        wg_if = f"v-{vpn_name}-w"
        return [
            SYSTEMD_DIR / f"vpn-ns-{vpn_name}.service",
            NETWORKD_DIR / f"10-{host_veth}.netdev",
            NETWORKD_DIR / f"10-{host_veth}.network",
            NETWORKD_DIR / f"20-{wg_if}.netdev",
            NETWORKD_DIR / f"30-{wg_if}.network",
        ]

    def _is_file_manually_modified(self, file_path):
        if not file_path.exists(): return False
        try:
            content = file_path.read_text()
            match = re.search(r'# HASH: ([a-f0-9]{64})', content)
            if not match: return True
            stored_hash = match.group(1)
            header, _, body = content.partition('\n# HASH: ')
            body = body.split('\n', 1)[1]
            actual_hash = hashlib.sha256(body.encode()).hexdigest()
            return stored_hash != actual_hash
        except Exception:
            return True

    def _prune_expired_clients(self):
        now = datetime.now(timezone.utc)
        original_count = len(self.vpn_clients["assignments"])
        active_assignments = []
        for client in self.vpn_clients["assignments"]:
            expiry_str = client.get("assignment_expiry")
            if expiry_str:
                try:
                    if datetime.fromisoformat(expiry_str.replace("Z", "+00:00")) < now:
                        logger.info(f"Pruning expired client: {client['display_name']}")
                        continue
                except (ValueError, TypeError):
                    logger.warning(f"Invalid expiry format for client '{client.get('display_name', 'N/A')}'")
            active_assignments.append(client)
        if len(active_assignments) < original_count:
            self.vpn_clients["assignments"] = active_assignments
            self._write_file(VPN_CLIENTS_PATH, json.dumps(self.vpn_clients, indent=2))

    def _manage_timer(self, enable: bool):
        self._run_cmd(["systemctl", "enable" if enable else "disable", "--now", "vpn-router.timer"], check=False)

    def _resolve_assignments(self):
        resolved_map = {}
        for client in self.vpn_clients.get("assignments", []):
            vpn_name = client.get("assigned_vpn")
            if not vpn_name: continue
            ip_address = client.get("ip_address")
            if not ip_address and client.get("hostname"):
                try:
                    ip_address = socket.gethostbyname(client["hostname"])
                except socket.gaierror:
                    logger.warning(f"Could not resolve hostname '{client['hostname']}'")
                    continue
            if ip_address:
                resolved_map.setdefault(vpn_name, []).append(ip_address)
        return resolved_map

    def _apply_vpn_config(self, vpn):
        vpn_name = vpn["name"]
        ns_name = f"ns-{vpn_name}"
        host_veth, ns_veth = f"v-{vpn_name}-v", f"v-{vpn_name}-p"
        wg_if = f"v-{vpn_name}-w"
        host_ip, ns_ip = self._get_network_addresses(vpn["veth_network"])

        logger.info(f"Applying network configuration for VPN '{vpn_name}'...")
        self._write_file(SYSTEMD_DIR / f"vpn-ns-{vpn_name}.service", f"[Unit]\nDescription=NetNS for {vpn_name}\n\n[Service]\nType=oneshot\nRemainAfterExit=yes\nExecStart=/usr/bin/ip netns add {ns_name}\nExecStop=/usr/bin/ip netns del {ns_name}\n\n[Install]\nWantedBy=multi-user.target")
        self._write_file(NETWORKD_DIR / f"10-{host_veth}.netdev", f"[NetDev]\nName={host_veth}\nKind=veth\n[Peer]\nName={ns_veth}")
        self._write_file(NETWORKD_DIR / f"10-{host_veth}.network", f"[Match]\nName={host_veth}\n[Network]\nAddress={host_ip}/30")
        self._write_file(NETWORKD_DIR / f"30-{ns_veth}.network", f"[Match]\nName={ns_veth}\n[Network]\nAddress={ns_ip}/30")
        self._write_file(NETWORKD_DIR / f"20-{wg_if}.netdev", f"[NetDev]\nName={wg_if}\nKind=wireguard\n[WireGuard]\nPrivateKey={vpn['client_private_key']}", 0o600)
        self._write_file(NETWORKD_DIR / f"30-{wg_if}.network", f"[Match]\nName={wg_if}\n[Network]\nAddress={vpn['vpn_assigned_ip']}\nDefaultRouteOnDevice=true\n[WireGuardPeer]\nPublicKey={vpn['peer_public_key']}\nEndpoint={vpn['peer_endpoint']}\nAllowedIPs=0.0.0.0/0")
        self._run_cmd(["systemctl", "daemon-reload"])
        self._run_cmd(["systemctl", "enable", "--now", f"vpn-ns-{vpn_name}.service"])
        self._run_cmd(["networkctl", "reload"])
        self._run_cmd(["ip", "link", "set", wg_if, "netns", ns_name], check=False)
        self._run_cmd(["ip", "link", "set", ns_veth, "netns", ns_name], check=False)
        self._run_cmd(["ip", "netns", "exec", ns_name, "systemctl", "restart", "systemd-networkd"], check=False)

    def _sync_host_routing(self, resolved_clients_map):
        logger.info("Synchronizing host policy routing...")
        for vpn_name, ips in resolved_clients_map.items():
            vpn = next((v for v in self.vpn_definitions['vpn_connections'] if v['name'] == vpn_name), None)
            if vpn:
                self._run_cmd(['ip', 'route', 'replace', 'default', 'dev', f"v-{vpn_name}-v", 'table', str(vpn['routing_table_id'])])
        
        desired_rules = {(ip, str(next(v['routing_table_id'] for v in self.vpn_definitions['vpn_connections'] if v['name'] == vpn))) for vpn, ips in resolved_clients_map.items() for ip in ips}
        current_rules = {m.groups() for m in re.finditer(r'from\s+([0-9\.]+)\s+lookup\s+(\d+)', self._run_cmd(['ip', 'rule', 'list']).stdout)}
        
        for ip, table in (current_rules - desired_rules): self._run_cmd(['ip', 'rule', 'del', 'from', ip, 'lookup', table])
        for ip, table in (desired_rules - current_rules): self._run_cmd(['ip', 'rule', 'add', 'from', ip, 'lookup', table, 'priority', '1000'])

    def _sync_nftables_nat(self, active_vpns):
        logger.info("Synchronizing nftables NAT rules...")
        config = self.vpn_definitions['system_config']['nftables']
        table, chain = config['table'], config['chain_masquerade']
        nft_config = f"flush chain {table} {chain}\n"
        for vpn_name in active_vpns:
            vpn = next((v for v in self.vpn_definitions['vpn_connections'] if v['name'] == vpn_name), None)
            if vpn:
                lan_subnets = self.vpn_definitions['system_config']['nat']['lan_subnets']
                nft_config += f"add rule {table} {chain} ip saddr {vpn['veth_network']} ip daddr != {{ {','.join(lan_subnets)} }} masquerade\n"
        rules_file = CONFIG_DIR / "nftables.rules.tmp"
        self._write_file(rules_file, nft_config)
        self._run_cmd(['nft', '-f', str(rules_file)])
        if not self.dry_run and rules_file.exists(): rules_file.unlink()

    def _cleanup_vpn_resources(self, vpn_name):
        logger.info(f"Cleaning up resources for orphaned VPN '{vpn_name}'...")
        self._run_cmd(["systemctl", "disable", "--now", f"vpn-ns-{vpn_name}.service"], check=False)
        for f in self._get_vpn_resource_files(vpn_name):
            if f.exists():
                logger.info(f"Removing file {f}")
                if not self.dry_run: f.unlink()
        self.changed_files.add("deleted_vpn_files")

    def _check_and_cleanup_orphans(self, active_vpns):
        logger.info("Checking for orphaned VPN resources...")
        system_vpn_names = {p.name.replace("vpn-ns-", "").replace(".service", "") for p in SYSTEMD_DIR.glob("vpn-ns-*.service")}
        orphaned_vpns = system_vpn_names - active_vpns
        
        for vpn_name in orphaned_vpns:
            files = self._get_vpn_resource_files(vpn_name)
            is_modified = any(self._is_file_manually_modified(f) for f in files)
            if is_modified:
                logger.warning(f"Orphaned VPN '{vpn_name}' has manually modified files and will not be cleaned up.")
                for f in files:
                    if f.exists(): logger.warning(f"  - {f}: {'modified' if self._is_file_manually_modified(f) else 'unchanged'}")
                continue
            self._cleanup_vpn_resources(vpn_name)

    def run(self):
        logger.info("Starting VPN Policy Router apply run...")
        self.changed_files.clear()
        self._prune_expired_clients()
        resolved_clients_map = self._resolve_assignments()
        active_vpns = set(resolved_clients_map.keys())
        self._manage_timer(enable=bool(self.vpn_clients.get("assignments")))
        self._check_and_cleanup_orphans(active_vpns)
        for vpn_name in active_vpns:
            vpn_config = next((v for v in self.vpn_definitions['vpn_connections'] if v['name'] == vpn_name), None)
            if vpn_config:
                self._apply_vpn_config(vpn_config)
        self._sync_host_routing(resolved_clients_map)
        self._sync_nftables_nat(active_vpns)
        if self.changed_files and not self.dry_run:
            logger.info("Configuration changed, reloading services...")
            self._run_cmd(["networkctl", "reload"])
        logger.info("Run completed.")

def main():
    parser = argparse.ArgumentParser(description="VPN Policy Router Apply Script")
    parser.add_argument("--dry-run", action="store_true", help="Show what would be done without making changes.")
    parser.add_argument("--verbose", action="store_true", help="Enable debug logging.")
    args = parser.parse_args()
    if args.verbose:
        logger.setLevel(logging.DEBUG)
    if os.geteuid() != 0:
        logger.error("This script must be run as root.")
        sys.exit(1)
    router = VPNRouter(dry_run=args.dry_run, auto_mode=True)
    router.run()

if __name__ == "__main__":
    main()
